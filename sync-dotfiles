#!/usr/bin/env bash

# Dotfiles Sync Script
# Synchronize dotfiles across multiple machines
# Usage: ./sync-dotfiles [push|pull|status|diff|list-machines]

set -e

# --- Configuration ---
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MACHINES_DIR="$DOTFILES_DIR/.machines"
CURRENT_MACHINE="$(hostname)"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_DIR="$DOTFILES_DIR/.backups/$TIMESTAMP"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Helper Functions ---

print_header() {
    echo -e "${BLUE}================================${NC}"
    echo -e "${BLUE}  Dotfiles Sync Manager${NC}"
    echo -e "${BLUE}================================${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

check_git() {
    if ! command -v git &> /dev/null; then
        print_error "Git is not installed. Please install git first."
        exit 1
    fi
}

check_repo() {
    if [ ! -d "$DOTFILES_DIR/.git" ]; then
        print_error "Not a git repository. Please initialize git first:"
        echo "  cd $DOTFILES_DIR && git init"
        exit 1
    fi
}

create_machine_profile() {
    mkdir -p "$MACHINES_DIR"
    local profile_file="$MACHINES_DIR/$CURRENT_MACHINE.json"

    if [ ! -f "$profile_file" ]; then
        print_info "Creating machine profile for: $CURRENT_MACHINE"

        cat > "$profile_file" <<EOF
{
  "hostname": "$CURRENT_MACHINE",
  "os": "$(uname -s)",
  "arch": "$(uname -m)",
  "created_at": "$(date -Iseconds)",
  "last_sync": null,
  "stowed_packages": []
}
EOF
        print_success "Machine profile created: $profile_file"
    fi
}

update_last_sync() {
    local profile_file="$MACHINES_DIR/$CURRENT_MACHINE.json"
    if [ -f "$profile_file" ]; then
        # Simple update without jq dependency
        sed -i.bak "s/\"last_sync\": \"[^\"]*\"/\"last_sync\": \"$(date -Iseconds)\"/" "$profile_file"
        rm -f "${profile_file}.bak"
    fi
}

create_backup() {
    if [ "$(git status --porcelain | wc -l)" -gt 0 ]; then
        print_info "Creating backup..."
        mkdir -p "$BACKUP_DIR"

        # Backup modified files
        git diff --name-only | while read -r file; do
            if [ -f "$file" ]; then
                local dir="$(dirname "$file")"
                mkdir -p "$BACKUP_DIR/$dir"
                cp "$file" "$BACKUP_DIR/$file"
            fi
        done

        print_success "Backup created: $BACKUP_DIR"
    fi
}

# --- Main Functions ---

sync_push() {
    print_header
    print_info "Pushing dotfiles to remote repository..."

    check_git
    check_repo
    create_machine_profile

    # Check for changes
    if [ -z "$(git status --porcelain)" ]; then
        print_info "No changes to push."
        return 0
    fi

    # Show status
    echo ""
    echo "Modified files:"
    git status --short
    echo ""

    # Confirm
    read -p "Do you want to commit and push these changes? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_warning "Push cancelled."
        return 0
    fi

    # Get commit message
    echo ""
    read -p "Enter commit message (or press enter for default): " commit_msg
    if [ -z "$commit_msg" ]; then
        commit_msg="sync: update from $CURRENT_MACHINE at $(date +"%Y-%m-%d %H:%M")"
    fi

    # Commit and push
    git add -A
    git commit -m "$commit_msg"

    if git push; then
        update_last_sync
        print_success "Successfully pushed to remote!"
    else
        print_error "Failed to push. You may need to pull first."
        exit 1
    fi
}

sync_pull() {
    print_header
    print_info "Pulling dotfiles from remote repository..."

    check_git
    check_repo
    create_machine_profile

    # Check for local changes
    if [ -n "$(git status --porcelain)" ]; then
        print_warning "You have local changes!"
        git status --short
        echo ""
        read -p "Create backup before pulling? [Y/n] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            create_backup
        fi
    fi

    # Pull changes
    if git pull --rebase; then
        update_last_sync
        print_success "Successfully pulled from remote!"
        print_info "Run './setup' or 'stow <package>' to apply changes"
    else
        print_error "Failed to pull. Resolve conflicts manually."
        exit 1
    fi
}

sync_status() {
    print_header
    print_info "Dotfiles Status"
    echo ""

    check_git
    check_repo

    # Git status
    echo "Git Status:"
    git status --short
    echo ""

    # Branch info
    local branch=$(git branch --show-current)
    local remote=$(git config --get "branch.$branch.remote" 2>/dev/null || echo "none")
    echo "Branch: $branch"
    echo "Remote: $remote"
    echo ""

    # Sync status
    if [ "$remote" != "none" ]; then
        git fetch --quiet
        local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
        local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")

        echo "Sync Status:"
        echo "  Behind remote: $behind commits"
        echo "  Ahead of remote: $ahead commits"
        echo ""
    fi

    # Machine info
    echo "Current Machine: $CURRENT_MACHINE"
    echo "OS: $(uname -s) $(uname -m)"

    local profile_file="$MACHINES_DIR/$CURRENT_MACHINE.json"
    if [ -f "$profile_file" ]; then
        local last_sync=$(grep "last_sync" "$profile_file" | cut -d'"' -f4)
        if [ "$last_sync" != "null" ] && [ -n "$last_sync" ]; then
            echo "Last Sync: $last_sync"
        else
            echo "Last Sync: Never"
        fi
    fi
}

sync_diff() {
    print_header
    print_info "Differences from remote"
    echo ""

    check_git
    check_repo

    # Fetch latest
    git fetch --quiet

    # Show diff
    git diff @{u}
}

list_machines() {
    print_header
    print_info "Registered Machines"
    echo ""

    if [ ! -d "$MACHINES_DIR" ] || [ -z "$(ls -A "$MACHINES_DIR" 2>/dev/null)" ]; then
        print_warning "No machines registered yet."
        return 0
    fi

    for profile in "$MACHINES_DIR"/*.json; do
        if [ -f "$profile" ]; then
            local hostname=$(grep "hostname" "$profile" | cut -d'"' -f4)
            local os=$(grep "\"os\"" "$profile" | cut -d'"' -f4)
            local last_sync=$(grep "last_sync" "$profile" | cut -d'"' -f4)

            echo "Machine: $hostname"
            echo "  OS: $os"
            if [ "$last_sync" != "null" ] && [ -n "$last_sync" ]; then
                echo "  Last Sync: $last_sync"
            else
                echo "  Last Sync: Never"
            fi
            echo ""
        fi
    done
}

show_help() {
    print_header
    cat << EOF
Usage: ./sync-dotfiles [command]

Commands:
  push              Commit and push local changes to remote
  pull              Pull changes from remote repository
  status            Show current sync status
  diff              Show differences from remote
  list-machines     List all registered machines
  help              Show this help message

Examples:
  ./sync-dotfiles push
  ./sync-dotfiles pull
  ./sync-dotfiles status

Workflow:
  1. Make changes to dotfiles on one machine
  2. Run: ./sync-dotfiles push
  3. On another machine, run: ./sync-dotfiles pull
  4. Apply changes with: ./setup or stow <package>

Notes:
  - Always commit meaningful changes
  - Pull before making new changes
  - Backups are created in .backups/ directory
  - Machine profiles are stored in .machines/ directory

EOF
}

# --- Main Script ---

main() {
    case "${1:-help}" in
        push)
            sync_push
            ;;
        pull)
            sync_pull
            ;;
        status)
            sync_status
            ;;
        diff)
            sync_diff
            ;;
        list-machines)
            list_machines
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "Unknown command: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

main "$@"
